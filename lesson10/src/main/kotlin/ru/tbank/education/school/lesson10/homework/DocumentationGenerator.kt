package ru.tbank.education.school.lesson10.homework

import kotlin.reflect.KParameter
import kotlin.reflect.full.declaredMemberFunctions
import kotlin.reflect.full.declaredMemberProperties
import kotlin.reflect.full.findAnnotation
import kotlin.reflect.jvm.jvmErasure

object DocumentationGenerator {
    fun generateDoc(obj: Any): String {
        val kClass = obj::class

        val classDoc = kClass.findAnnotation<DocClass>()
            ?: return "Нет документации для класса."

        if (kClass.findAnnotation<InternalApi>() != null) {
            return "Документация скрыта (InternalApi)."
        }

        val sb = StringBuilder()

        val className = kClass.simpleName ?: "Unknown"
        sb.append("=== Документация: $className ===\n")
        sb.append("Описание: ${classDoc.description}\n")
        sb.append("Автор: ${classDoc.author}\n")
        sb.append("Версия: ${classDoc.version}\n\n")

        val hiddenPropertyNames = kClass.declaredMemberProperties
            .filter { it.findAnnotation<InternalApi>() != null }
            .map { it.name }
            .toSet()

        val props = kClass.declaredMemberProperties
            .filter { it.findAnnotation<InternalApi>() == null }

        if (props.isNotEmpty()) {
            sb.append("--- Свойства ---\n")
            for (prop in props) {
                sb.append("- ${prop.name}\n")
                val propDoc = prop.findAnnotation<DocProperty>()
                if (propDoc != null) {
                    sb.append("  Описание: ${propDoc.description}\n")
                    if (propDoc.example.isNotEmpty()) {
                        sb.append("  Пример: ${propDoc.example}\n")
                    }
                }
            }
            sb.append("\n")
        }

        val autoGeneratedNames = setOf("toString", "equals", "hashCode", "copy")
        val methods = kClass.declaredMemberFunctions
            .filter { fn ->
                if (fn.findAnnotation<InternalApi>() != null) return@filter false
                val name = fn.name
                if (name in autoGeneratedNames) return@filter false
                if (name.startsWith("component")) return@filter false
                true
            }

        if (methods.isNotEmpty()) {
            sb.append("--- Методы ---\n")
            for (fn in methods) {

                val allParams = fn.parameters.filter { it.kind == KParameter.Kind.VALUE }
                val visibleParams = allParams.filter { p ->
                    val pname = p.name
                    pname == null || pname !in hiddenPropertyNames
                }

                val paramsStr = visibleParams.joinToString(", ") { p ->
                    val typeName = p.type.jvmErasure.simpleName ?: p.type.toString()
                    "${p.name}: $typeName"
                }

                sb.append("- ${fn.name}($paramsStr)\n")

                val methodDoc = fn.findAnnotation<DocMethod>()
                if (methodDoc != null) {
                    sb.append("  Описание: ${methodDoc.description}\n")
                }

                if (visibleParams.isNotEmpty()) {
                    sb.append("  Параметры:\n")
                    for (p in visibleParams) {
                        val paramDoc = p.findAnnotation<DocParam>()
                        val desc = paramDoc?.description ?: "Нет описания"
                        sb.append("    - ${p.name}: $desc\n")
                    }
                }

                val returnsDesc = methodDoc?.returns ?: "Нет описания"
                sb.append("  Возвращает: $returnsDesc\n")
            }
        }

        return sb.toString().trimEnd()
    }
}
